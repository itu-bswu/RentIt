\section{Client}
\label{Design_Client}
This section covers design decisions we made regarding the client implementation and Graphical User Interface (GUI) design.
\subsection{Analysis}
\label{Design_Client_Analysis}
We looked into what architectures were commonly used and suggested when developing a client with a GUI front-end and a WCF-service backend. We have seen (and used) the Model-View-Control (MVC\footnote{Wikipedia description of Model-View-Control\cite{WIKI-MVC}}) before this project, and we felt it fit nicely with having a model (the service), a view (GUI) and a controller to make it all work. 
\\While looking into MVC and how we could apply to our client, we found the Model-View-Viewmodel (MVVM\footnote{References on Wikipedia \cite{WIKI-MVVM} and MSDN \cite{MSDN-WPF-MVVM}}) architecture pattern. The MVVM pattern is based largely on MVC, but is targeted at modern UI development platforms (such as HTML5, Windows Presentation Foundation and Silverlight).

Because we decided to use Windows Presentation Foundation (WPF)\footnote{Decision described in section \ref{Implementation_Client} on page \pageref{Implementation_Client}.}, we decided that trying out the MVVM pattern felt like a good idea. MVVM offers a complete seperation of the model (in our case the WCF service) and the Graphical User Interface (GUI). The viewmodels serve as translators (and sometimes logic functionality, depending on implementation).
\subsection[Architecture]{Our version of the MVVM Architecture}
\label{Design_Client_Architecture}
Having decided on using the MVVM architecture, we decided to implementing our own version of it (instead of using frameworks set up to use MVVM). It gave us more control over what we wanted to do with the architecture, as well as 
\subsection{Graphical User Interface}
\label{Design_Client_GUI}

\subsubsection{Usability}
\label{Design_Client_GUI_Usability}
When we sat down to design our GUI, we felt that it was important that we had a user friendly interface, we therefore choosed to make some usability tests (see \ref{Testing_Strategy_Usability}) since they will allways grant some degree of usability if performed correctly.
From these test we got the feedback that we didn't have enough user confirmation, so we therefore incorporated alot of dialogboxses into our design.

(.............. billed af dialogbox)

 we first made some paper mockups\footnote{see appendix for mockups}, which focused on the aspect of a very clean environment, with the least amount of redundent data, and buttons. When we then asked the test subjects how they felt about the interface, we then got the feedback that there was to little confirmation in the interface they felt uncertain that there changes was being saved or whatever they had rented a certain movie. When then took that feedback into account and went about making a digital alpha version\footnote{see appendix for screenshots} of interface which had alot more dialogboxses than the paper mockups.


 which we used to make the first round of usability tests. From the first test we got the feed back that our system didn't give the user enough feedback in form of dialogboxses and save changes buttons, when then took that into account and started working on a alpha client which we could use for the second test.





mangler at lave Usability test p√• clienten.