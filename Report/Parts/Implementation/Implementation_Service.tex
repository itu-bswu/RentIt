\section{Service}
\label{Implementation_Service}

\subsection[Architecture]{Architecture implementation}
\label{Implementation_Service_Architecture}

\subsubsection{Issues, workarounds and fixes}
\label{Implementation_Service_Architecture_Issues}

One of the issues we kept working on throughout the project, was how to use Entity Framework properly. Initially we created a new context every time we needed data from the database. The problem with this approach, is that if we pass entity instances around (internal in the service), we can't use an instance from one context in another. This meant that we had to find the object again in the new context, before we could use it.

We later found out that the best practice for ASP.NET websites was to use a context for the entire request, and dispose it after the response was sent to the client. Since our service behaves the same way as a website, we decided to implement this approach. This proved to be a lot better, as we no longer has to create a new context all the time, and we didn't have to find the same object in a new context all the time. The only time we had to ``synchronize'' an object with the context, was with the objects we received as parameters. We did this in the service layer, which meant that we throughout the logic layer could trust all objects. This also meant that it would make sense to change our logic methods (which was primarily static methods) to instance methods, which provided a much nicer, more consistent and cleaner design throughout the logic layer.

Another problem with Entity Framework was whether or not to use lazy loading. With lazy loading all one-to-many and many-to-many relations was only loaded when it was requested. To do this, it created a proxy for the entity class behind the scenes. The problem with this was that these objects were passed to the client, where they failed due to no connection to the database through Entity Framework.

We fixed this by disabling lazy loading and proxy creation. But disabling lazy loading doesn't enable eager loading. There isn't such thing as an eager loading setting to enable, which meant that all of a sudden our one-to-many and many-to-many relations weren't loaded at all. We had to manually load them through calling Include() method in our LINQ-to-Entities queries. This wasn't very nice, and it was very easy to forget this, which lead to problems very hard to debug.

We solved this by creating a static property on each entity class, called All. This called all necessary Include() to get it to properly get all information for that specific entity. By using this as a base for our LINQ-to-Entities queries (by using \method{Movie.All} instead of \method{DbContext.Movies} as base) we were ensured to always have all relations available. This also means that we always load all data, even when we don't need it. But we think this is an acceptable sacrifice, as we did get some code that was a lot nicer and cleaner, and less error-prone (as we couldn't forget to Include() what we needed).

Another difficulty we experienced, was with WCF. We used \class{MessageContract} (instead of \class{DataContract}) for our \class{RemoteFileStream}, as we gained more control over the SOAP message that way, and because we couldn't get it to function properly with \class{DataContract}. But we discovered that when using a class with \class{MessageContract} attribute as a parameter, no other types of parameters could be used. That meant that we had to move token and \class{Edition} (to identify which edition to download, or to pass name and movie id for uploading) to \class{RemoteFileStream}. Another quirk was that when using a class with \class{MessageContract} attribute as a parameter, we either had to return nothing or return something of the same type as the input parameter. This was also true for the other way around (using a class with \class{MessageContract} attribute as return type).

Because of that we changed \method{RentalManagement.DownloadFile} to take a  \class{RemoteFileStream} as parameter (to identity the user and the movie edition to download) and return a  \class{RemoteFileStream} with the stream. We also changed \method{ContentManagement.UploadEdition} to take a \class{RemoteFileStream} as parameter and changed the return type to \method{void}. This meant a slightly inconsistent service interface, but the service interface was to begin with quite consistent, and we agreed that these small inconsistencies were acceptable, to get it working.