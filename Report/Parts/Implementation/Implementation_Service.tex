\section{Service}
\label{Implementation_Service}

\subsection[Architecture]{Architecture implementation}
\label{Implementation_Service_Architecture}
We have two parts of our service implementation: the service layer and the logic layer. The service layer is our public API, while the logic layer is our private, inner mechanics. Their purpose is clearly defined in their design: the service layer is completely build around the API we have designed, while the logic layer is designed to be compatible with Entity Framework. 

Our API is divided into four main categories: user management, content browsing, rental management and content management. For each of these, we have a class in the service, which implements all public methods to do what we want the user to be able to. The classes are \class{UserManagement}, \class{ContentBrowsing}, \class{RentalManagement} and \class{ContentManagement}. 

The logic layer is not based around the interface, but based on being compatible with Entity Framework. The core classes in this layer is our entities. They each corresponds to a table in our database, and is mapped to these, so that instances of these classes can represent data in our database. Along with being used as database structures, they also contains the logic associated with each entity. These are defined as either class- or instance methods. These methods implements both the CRUD functionality we want per entity, but also general functionality that relates to it, without actually utilizing a specific instance. An example of this is the search method on the \class{Movie} class, which is a static method, but returns a collection of movies, that matched the search criteria. 

Each entity have an All property defined. This is a way we use to abstract away from Entity Framework. Instead of manually getting a context to get an enumerator of all instances in the database, we just use this property. It's both easier to use, and it's more secure, since it adds abstraction. 

To communicate with the database, we have the \class{RentItContext} object, which is an Entity Framework object context. This class has a set of all out entities, which is mapped to the tables in the database, so that it will pull the data from there, when we're iterating through. This class is the way we handle reads and writes to the database. The intended way to use it is to create a new context each time you want to access the database in some way. Unfortunately, this conflicted with the way we had chosen to do POCO classes, because the same object received from two different contexts weren't compatible. This caused a lot of trouble, so we ended up with instead having a shared singleton instance, which is lazily initialized first time it's accessed, and will be preserved for the next call you want to make through it. If you want to reload it, we made a method for disposing the context, and a new one would be initialized next time the context was accessed. This solved a lot of the problems we had, because the same context was now used all the time. The only problem was that a multithreaded service would still access the same context, and multiple requests being processed at the same time would cause trouble. That's why we store the context in a thread local storage. This makes sure that a context will only exist in a single thread, and if another thread tries to access it, a new one will be initialized to run in parallel.

\subsubsection{Issues, workarounds and fixes}
\label{Implementation_Service_Architecture_Issues}

One of the issues we kept working on throughout the project, was how to use Entity Framework properly. Initially we created a new context every time we needed data from the database. The problem with this approach, is that if we pass entity instances around (internal in the service), we can't use an instance from one context in another. This meant that we had to find the object again in the new context, before we could use it.

We later found out that the best practice for ASP.NET websites was to use a context for the entire request, and dispose it after the response was sent to the client. Since our service behaves the same way as a website, we decided to implement this approach. This proved to be a lot better, as we no longer has to create a new context all the time, and we didn't have to find the same object in a new context all the time. The only time we had to ``synchronize'' an object with the context, was with the objects we received as parameters. We did this in the service layer, which meant that we throughout the logic layer could trust all objects. This also meant that it would make sense to change our logic methods (which was primarily static methods) to instance methods, which provided a much nicer, more consistent and cleaner design throughout the logic layer.

Another problem with Entity Framework was whether or not to use lazy loading. With lazy loading all one-to-many and many-to-many relations was only loaded when it was requested. To do this, it created a proxy for the entity class behind the scenes. The problem with this was that these objects were passed to the client, where they failed due to no connection to the database through Entity Framework.

We fixed this by disabling lazy loading and proxy creation. But disabling lazy loading doesn't enable eager loading. There isn't such thing as an eager loading setting to enable, which meant that all of a sudden our one-to-many and many-to-many relations weren't loaded at all. We had to manually load them through calling Include() method in our LINQ-to-Entities queries. This wasn't very nice, and it was very easy to forget this, which lead to problems very hard to debug.

We solved this by creating a static property on each entity class, called All. This called all necessary Include() to get it to properly get all information for that specific entity. By using this as a base for our LINQ-to-Entities queries (by using \method{Movie.All} instead of \method{DbContext.Movies} as base) we were ensured to always have all relations available. This also means that we always load all data, even when we don't need it. But we think this is an acceptable sacrifice, as we did get some code that was a lot nicer and cleaner, and less error-prone (as we couldn't forget to Include() what we needed).

Another difficulty we experienced, was with WCF. We used \class{MessageContract} (instead of \class{DataContract}) for our \class{RemoteFileStream}, as we gained more control over the SOAP message that way, and because we couldn't get it to function properly with \class{DataContract}. But we discovered that when using a class with \class{MessageContract} attribute as a parameter, no other types of parameters could be used. That meant that we had to move token and \class{Edition} (to identify which edition to download, or to pass name and movie id for uploading) to \class{RemoteFileStream}. Another quirk was that when using a class with \class{MessageContract} attribute as a parameter, we either had to return nothing or return something of the same type as the input parameter. This was also true for the other way around (using a class with \class{MessageContract} attribute as return type).

Because of that we changed \method{RentalManagement.DownloadFile} to take a  \class{RemoteFileStream} as parameter (to identity the user and the movie edition to download) and return a  \class{RemoteFileStream} with the stream. We also changed \method{ContentManagement.UploadEdition} to take a \class{RemoteFileStream} as parameter and changed the return type to \method{void}. This meant a slightly inconsistent service interface, but the service interface was to begin with quite consistent, and we agreed that these small inconsistencies were acceptable, to get it working.