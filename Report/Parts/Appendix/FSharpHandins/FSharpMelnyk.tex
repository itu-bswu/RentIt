\section{F\# Handins - Jakob Melnyk}
\label{Appendix_FSharp_Melnyk}

\subsection{HandIn 1}
\label{Appendix_FSharp_Melnyk_1}
\begin{lstlisting}
module Module1

// Exercise 1
let sqr x = x*x

// Exercise 2
let pow x n = System.Math.Pow(x, n)

// Exercise 3
let dup s : string = s + s

// Exercise 4
let rec dupn (s:string) x = 
	if x>=1 then (if x = 1 then s else s + dupn s (x-1)) else ""

// Exercise 5
let timediff (hh1, mm1)(hh2, mm2) = (hh2*60 + mm2)-(hh1*60 + mm1)

// Exercise 6
let minutes (hh, mm) = timediff(00, 00)(hh, mm)
\end{lstlisting}
\subsection{HandIn 2}
\label{Appendix_FSharp_Melnyk_2}
\begin{lstlisting}
module Module2

// Exercise 7
let rec downTo x = 
	if x < 1 then [] else (if x = 1 then [x] else x :: downTo (x - 1))

let rec downTo2 x = 
    match x with
    | x when x < 1 -> []
    | 1 -> [1]
    | _ -> x :: downTo2 (x - 1)

// Exercise 8
let rec removeEven (x:int list) = 
    match x with 
    | [] -> []
    | [xs] -> [xs]
    | xs :: ys :: zs -> xs :: removeEven zs

// Exercise 9
let rec combinePair (x:int list) : (int * int) list = 
    match x with
    | [] -> []
    | [xs] -> []
    | xs :: ys :: zs -> (xs, ys) :: combinePair zs

// Exercise 10
let explode (s:string) = List.ofArray (s.ToCharArray())

let rec explode2 (s:string) : char list = 
    match s with
    | s when s.Length < 1  -> []
    | _ -> s.[0] :: explode2 (s.Substring 1)

// Exercise 11
let implode (cl:char list) : string = 
		List.foldBack (fun elem acc -> string(elem) + string(acc) ) cl ""

let implodeRev (cl:char list) : string = 
		List.fold (fun elem acc -> string(acc) + string(elem) ) "" cl 

// Exercise 12
let toUpper (s:string) = implode (List.map System.Char.ToUpper (explode s))

let toUpper1 = explode >> List.map System.Char.ToUpper >> implode

let toUpper2 (s:string) = explode s |> (implode << List.map System.Char.ToUpper)

// Exercise 13
let palindrome (s:string) = (explode s |> implodeRev |> toUpper) = toUpper s

// Exercise 14
let rec ack (m, n) = 
    match (m, n) with
    | (m, n) when m < 0 || n < 0 -> failwith "The Ackermann function 
				is defined for non negative numbers only."
    | (m, n) when m = 0 -> n + 1
    | (m, n) when n = 0 -> ack (m - 1, 1)
    | (m, n) -> ack(m - 1, ack (m, n - 1))

// Exercise 15
let time f = 
    let start = System.DateTime.Now in
    let res = f () in
    let finish = System.DateTime.Now in
    (res, finish - start)

let timeArg1 f a = time(fun () -> f(a))
\end{lstlisting}
\subsection{HandIn 3}
\label{Appendix_FSharp_Melnyk_3}
\begin{lstlisting}
\end{lstlisting}
\subsection{HandIn 4 \& 5}
\label{Appendix_FSharp_Melnyk_4and5}
\begin{lstlisting}
\end{lstlisting}