\section{F\# Handins - Jacob Claudius Grooss}
\label{Appendix_FSharp_Grooss}

\subsection{HandIn 1}
\label{Appendix_FSharp_Grooss_1}
\begin{lstlisting}
module HandIn1
//Exercise 1
let sqr x = x * x

//Exercise 2
let pow x n = System.Math.Pow(x, n)

//Exercise 3
let dup (s:string) = s + s

//Exercise 4
let rec dupn (s:string, x) = if x = 0 then s else s + dupn(s, x - 1)

//Exercise 5
let timediff (hh1, mm1)(hh2, mm2) = (hh2 * 60 + mm2) - (hh1 * 60 + mm1)

//Exercise 6
let minutes (hh, mm) = timediff (00,00)(hh,mm)
\end{lstlisting}
\subsection{HandIn 2}
\label{Appendix_FSharp_Grooss_2}
\begin{lstlisting}
//Exercise 7
let rec downTo n = if n < 1 then [] else n :: downTo(n - 1)

let rec downTo2 n = 
    match n with
		| n when n < 1 -> []
        | 1 -> [1]
        | _ -> n :: downTo(n-1)

//Exercise 8
let rec removeEven (xs: int list) =
    match xs with
        | [] -> []
        | [xs] -> [xs]
        | xs :: xy :: rs -> xs :: removeEven(rs)

//Exercise 9
let rec combinePair (xs: int list) =
    match xs with
        | [] -> []
        | [xs] -> []
        | xs :: xy :: rs -> xs :: combinePair(rs)

//Exercise 10
let explode (s:string) =
    s.ToCharArray() |> List.ofArray

let rec explode2 (s:string) =
    match s with
        | s when s.Length < 1 -> []
        | _ -> s.[0] :: explode2 (s.Substring 1)

//Exercise 11
let implode (s:char list) =
    List.foldBack (fun str ch -> string(str) + string(ch)) s ""
    
let implodeRev (s:char list) =
    List.fold (fun str ch -> string(ch) + string(str)) "" s

//Exercise 12
let toUpper (s:string) =
    implode (List.map (fun x -> System.Char.ToUpper x) (explode s))

let toUpper1 (s:string) =
    explode >> (List.map (System.Char.ToUpper)) >> implode

let toUpper2 (s:string) =
    explode s |> (implode << List.map System.Char.ToUpper)

//Exercise 13
let palindrome (s:string) =
    (explode s |> implodeRev |> toUpper) = toUpper s

//Exercise 14
let rec ack (m, n) =
    match (m, n) with
        | (m, n) when m < 0 || n < 0 -> failwith "The Ackermann function 
				is defined for non negative numbers only."
        | (m, n) when m = 0 -> n + 1
        | (m, n) when n = 0 -> ack (m - 1, 1)
        | (m, n) -> ack (m-1, ack(m, n-1))

//Exercise 15
let time f =
    let start = System.DateTime.Now in
    let res = f () in
    let finish = System.DateTime.Now in
    (res, finish - start);

let timeArg1 f a = time(fun () -> f(a))
\end{lstlisting}
\subsection{HandIn 3}
\label{Appendix_FSharp_Grooss_3}
\begin{lstlisting}
type 'a BinTree =
    | Node of 'a * 'a BinTree * 'a BinTree
    | Leaf;;

let intBinTree = Node(43, Node(25, Node(56, Leaf, Leaf), Leaf),
Node(562, Leaf, Node(78, Leaf, Leaf)));;

//Exercise 16
let rec inOrder tree =
    match tree with
    | Leaf -> []
    | Node (n, treeL, treeR) ->
    inOrder treeL @ n :: inOrder treeR;;

//Exercise 17
let rec mapInOrder (funct: 'a -> 'b) tree =
    match tree with
    | Leaf -> Leaf
    | Node (n, treeL, treeR) ->
        let left = mapInOrder funct treeL
        let value = funct n
        let right = mapInOrder funct treeR
        Node (value, left, right);;

(* They traverse the tree in different orders,
which can give different results. *)

//Exercise 18
//Doesn't have the right signature, but this was the closest I could get
//to it while getting the correct result
let rec foldInOrder funct acc tree =
    match tree with
    | Leaf -> acc
    | Node (root, treeL, treeR) -> 
    funct (foldInOrder funct acc treeL) root (foldInOrder funct acc treeR);;

let func left root right = left + root + right;;

let seed = 1;;

let testingFol = foldInOrder func seed intBinTree;;

//Exercise 19 / 21 / 22
type expr =
    | Const of int
    | If of expr * expr * expr
    | Bind of string * expr * expr
    | Var of string
    | Prim of string * expr * expr

let rec evaluate expr (dict: 
System.Collections.Generic.Dictionary<string, expr>) =
    match expr with
    | Const(i) -> 
        i
    | If(expr1, expr2, expr3) ->
        if ((evaluate expr1 dict) > 0 || (evaluate expr1 dict) < 0) 
        then (evaluate expr2 dict) else (evaluate expr3 dict)
    | Bind(var, value, expr1) ->
        dict.Add(var, value)
        evaluate expr1 dict
    | Var(text) when dict.ContainsKey(text) ->
        evaluate (dict.Item text) dict
    | Var(text) -> 
        failwithf "Unknown variable '\%s'" text
    | Prim("-", expr1, expr2) -> 
        evaluate expr1 dict - evaluate expr2 dict
    | Prim("+", expr1, expr2) -> 
        evaluate expr1 dict + evaluate expr2 dict
    | Prim("max", expr1, expr2) -> 
        (List.max [evaluate expr1 dict; evaluate expr2 dict])
    | Prim("min", expr1, expr2) -> 
        (List.min [evaluate expr1 dict; evaluate expr2 dict])
    | Prim("=", expr1, expr2) -> 
        if (evaluate expr1 dict).Equals(evaluate expr2 dict) then 1 else 0
    | Prim(opr, _, _) -> 
        (printfn "Operation '\%s' not supported" opr; 0);;

let eval expr =
    evaluate expr (new System.Collections.Generic.Dictionary<string, expr>());;

//Exercise 20
let testingMinus = eval (Prim("-", Const 10, Const 5));;
let testingPlus = eval (Prim("+", Const 10, Const 5));;
let testingMx = eval (Prim("max", Const 10, Const 5));;
let testingMin = eval (Prim("min", Const 10, Const 5));;
let testingEquals = eval (Prim("=", Const 10, Const 5));;

let testingIf1 = eval (If(Const 3, Const 20, Const 18));;
let testingIf2 = eval (If(Const 0, Const 20, Const 18));;

//Exercise 23
let testingBindVal1 = eval (Bind("troll", Const 20, 
Bind("anti-troll", Const 42, Bind("super-troll", Var "troll", 
Var "anti-troll"))));;
let testingBindVal2 = eval (Bind("what", 
Bind("happens", Const 20, Var "happens"), Var "what"));;
let testingBindVal3 = eval (Bind("lol", Const 1337, Var "lol"));;
let testingVarFail1 = eval (Var("troll"));;
let testingVarFail2 = eval (Bind("fail", Const 117, Var "troll"));;
\end{lstlisting}

\subsection{HandIn 4 \& 5}
\label{Appendix_FSharp_Grooss_4and5}
\begin{lstlisting}
(*------------------------------------------------------------------*
 * The professor game is about placing 16 cards with two professor  *
 * jackets and two professor trousers in different colors on a      *
 * square board.                                                    *
 * This program finds all solutions to a given set of cards.        *
 * Visit http://boardgamegeek.com/boardgame/15800/professorspillet  *
 * to get an idea of how the game works.                            *
 *                                                                  *
 * 27/12/1995, Niels Hallenberg (Written i SML)                     *
 * 27/03/2009, Niels Hallenberg (Ported to F#)                      *
 * 09/04/2012, Niels Hallenberg (Adjusted to be used for exercise)  *
 *------------------------------------------------------------------*)


(* Do not change the two functions doImpl4 and doImpl5 - they are used
   to show where you put in your own code. *)
exception ToBeImplemented of string
let doImpl4 s = raise (ToBeImplemented ("Hand-in 04: " + s)) 
(* do not change *)
let doImpl5 s = raise (ToBeImplemented ("Hand-in 05: " + s)) 
(* do not change *)

(* listTake: returns a new list with first n items in the list xs. *)
let rec listTake n xs = 
  match (n,xs) with
    (0,_) -> []
  | (n,x::xs) -> x::listTake (n-1) xs  
  | _ -> failwith "listTake - n out of range"

(*-------------------------------------------*
 * Datatypes and simple operations.          *
 *-------------------------------------------*)

(* Definde a data type clothes representing the possible clothes. 
I.e. a red jacket, red trousers etc. *)
type clothes = 
  | RED_JACKET
  | RED_TROUSERS
  | GREEN_JACKET  
  | GREEN_TROUSERS
  | BLUE_JACKET  
  | BLUE_TROUSERS
  | BROWN_JACKET  
  | BROWN_TROUSERS

(* Define a record type card to hold the piece of clothe at the 
top, buttom, left and right. *)

type card = 
  {top:clothes;
   bot:clothes;
   left:clothes;
   right:clothes}

(* Define the 16 cards that you have to place in 4 rows and 4 columns *)
let cardSet = 
               [{top= BLUE_TROUSERS; bot=BROWN_JACKET; 
                left= BLUE_JACKET; right=BROWN_TROUSERS};
               {top=BROWN_TROUSERS; bot=GREEN_JACKET; 
                left=BROWN_JACKET; right=  RED_TROUSERS};
               {top=GREEN_TROUSERS; bot=GREEN_JACKET; 
                left=  RED_JACKET; right= BLUE_TROUSERS};
               {top=BROWN_TROUSERS; bot=BROWN_JACKET; 
                left= BLUE_JACKET; right=  RED_TROUSERS};
               {top=BROWN_TROUSERS; bot=GREEN_JACKET; 
                left= BLUE_JACKET; right=  RED_TROUSERS};
               {top=GREEN_TROUSERS; bot=BROWN_JACKET; 
                left=  RED_JACKET; right= BLUE_TROUSERS};
               {top=GREEN_TROUSERS; bot=BROWN_JACKET; 
                left= BLUE_JACKET; right=  RED_TROUSERS};
               {top=BROWN_TROUSERS; bot= BLUE_JACKET; 
                left=  RED_JACKET; right=GREEN_TROUSERS};
               {top=GREEN_TROUSERS; bot=BROWN_JACKET; 
                left=  RED_JACKET; right=GREEN_TROUSERS};
               {top=BROWN_TROUSERS; bot=GREEN_JACKET; 
                left=GREEN_JACKET; right= BLUE_TROUSERS};
               {top=BROWN_TROUSERS; bot=GREEN_JACKET; 
                left= BLUE_JACKET; right=  RED_TROUSERS};
               {top= BLUE_TROUSERS; bot=BROWN_JACKET; 
                left=  RED_JACKET; right=GREEN_TROUSERS};
               {top=BROWN_TROUSERS; bot=  RED_JACKET; 
                left=GREEN_JACKET; right= BLUE_TROUSERS};
               {top=GREEN_TROUSERS; bot=  RED_JACKET; 
                left= BLUE_JACKET; right=BROWN_TROUSERS};
               {top=GREEN_TROUSERS; bot= BLUE_JACKET; 
                left=BROWN_JACKET; right=  RED_TROUSERS};
               {top=BROWN_TROUSERS; bot=GREEN_JACKET; 
                left=  RED_JACKET; right=GREEN_TROUSERS}]

(* Define the board. There are indeed many ways to represent the board. 
   You must use the below representation - not because it 
   is particular intelligent - 
   it certainly isn't - but because it is fairly easy to 
   understand and work with. 

   The board is represented as a
     a) list of cards
     b) current column number
     c) current row number

   The idea is that we add one card at the time to the board and 
   increase col/row as we go along.
   We only add valid cards, of course. If we, at some point, get 
   a board with 16 cards (4 rows and 4 columns),
   then we have a solution. *)
type row = int
type col = int
type board = row*col*(card list)

(* Define the empty board, i.e., no cards added. 
We start by column 0 and row 0. *)
let emptyBoard = (0, 0, [])
let colNo = 4 (* number of columns on board. *)
let rowNo = 4 (* number of rows on board.    *)

(* Define four functions that given a card 
with return one of the four clothes on the card. *)
let findBot (card:card) = card.bot
let findTop (card:card) = card.top
let findLeft (card:card) = card.left
let findRight (card:card) = card.right

(* Calculate index in list given row and column. *)
(* Define a function given row and column
 to calculate the index of that coordinate in the list. 
   Notice, that the first row and column has index 0. *)
let findIndexInList (row, col) = row*colNo+col

(* Define a function add that given a coordinate (row,col) 
   finds a new coordinate (row',col') 
   n places to the right (if n is positive) and 
   n places to the left (if n is negative). *)
let add n (row, col) =
  let row' = (row*colNo+n+col) / colNo
  let col' = (row*colNo+n+col) \% colNo
  (row', col')

(*--------------------------*
 * PrettyPrinting           *
 *--------------------------*)

(* Define a function that as a string 
returns a pretty print of the clothes. *)
let pp_clothes clothes =
  match clothes with
    | RED_JACKET     -> "RED_JACKET    "
    | RED_TROUSERS   -> "RED_TROUSERS  "
    | GREEN_JACKET   -> "GREEN_JACKET  "
    | GREEN_TROUSERS -> "GREEN_TROUSERS"
    | BLUE_JACKET    -> "BLUE_JACKET   "
    | BLUE_TROUSERS  -> "BLUE_TROUSERS "
    | BROWN_JACKET   -> "BROWN_JACKET  "
    | BROWN_TROUSERS -> "BROWN_TROUSERS"

(* Define a function to output a string s on the console. *)
let output s = printf "\%s" s

(* Define a function die, to output an error string s 
    on the console and afterwards raises
   an exception to stop program execution. *)
let die s = (output("Professor_game - DIE with message: " + s);
             failwith s)

(* Define a set of pretty print functions to pretty print 
    a board containing a number of cards. *)
let pp_newline () = output "\n"
let pp_board_line () = output
     "+--------------------------------++--------------------------------+
      +--------------------------------++--------------------------------+\n"
let pp_vertical xs = (List.iter (fun clothe -> output
     ("|         " + (pp_clothes clothe) + "         |")) xs; pp_newline())
let pp_horizontal xs = (List.iter (fun (l, r) -> output
     ( "|" + (pp_clothes l) + "    " + (pp_clothes r) + "|")) xs; pp_newline())

let pp_row cards =
  let tops = List.map findTop cards
  let bots = List.map findBot cards
  let lefts = List.map findLeft cards
  let rights = List.map findRight cards
  let centerRow = List.zip lefts rights
  (pp_board_line();
   pp_vertical tops;
   pp_horizontal centerRow;
   pp_vertical bots;
   pp_board_line ())

(* Split list [x1,...,xN] in the lists [x1,...,xn-1] and [xn,...,xN] *)
(* where n >= 0 and n < N .                                          *)
(* Fx: splitNth (0,[1;2]) gives ([], [1; 2])                         *)
(*     splitNth (1,[1;2]) gives ([1], [2])                           *)
(*     splitNth (2,[1;2]) gives ([1; 2], [])                         *)
(*     splitNth (3,[1;2]) should die : 3 outside range of list       *)
(*     splitNth (-1,[1;2]) should die : -1 outside range of list     *)
let rec splitNth (n, xs) = 
    match (n, xs) with
    | (0, xs) -> ([], xs)
    | (n, x :: xs) -> let (a, b) = splitNth (n - 1, xs);
                      (x :: a, b)
    | _ -> failwith "The input is out of range"

(* IT IS REQUIRED THAT THE OUTPUT MATCHES THE EXAMPLES BELOW EXACTLY!!!   *)
(* Please use the helper functions above: pp_horizontal, pp_vertical etc. *)
(* PrettyPrint all cards - colNo says number of columns on the board.     *)
(* colNo is defined to be 4 above.                                        *)
(* A few examples of output below.                                        *)
let rec pp_cards (cards : card list) = 
    match cards with
    | [] -> ()
    | card when cards.Length <= 4 -> pp_row (cards)
    | _ -> let (a, b) = splitNth(colNo, cards);
      pp_row a; pp_cards b
 
let _ = pp_cards (listTake 1 cardSet)
let _ = pp_cards (listTake 2 cardSet)
let _ = pp_cards (listTake 4 cardSet)
let _ = pp_cards (listTake 5 cardSet)
let _ = pp_cards cardSet

let pp_board (row, col, cards) =
  (output "New board\n";
   pp_cards cards;
   pp_newline())

let pp_boards boards = List.iter pp_board boards

(*---------------*
 * Solving board *
 *---------------*)

(* matchClothes: the valid combinations of clothe.  *)
(* There are 8 valid combinations                   *)
let matchClothes clothe1 clothe2 =
  match (clothe1,clothe2) with
    | (RED_JACKET,RED_TROUSERS) -> true
    | (RED_TROUSERS,RED_JACKET) -> true
    | (GREEN_JACKET,GREEN_TROUSERS) -> true
    | (GREEN_TROUSERS,GREEN_JACKET) -> true
    | (BLUE_JACKET,BLUE_TROUSERS) -> true
    | (BLUE_TROUSERS,BLUE_JACKET) -> true
    | (BROWN_JACKET,BROWN_TROUSERS) -> true
    | (BROWN_TROUSERS,BROWN_JACKET) -> true
    | _ -> false

(* matchTop: Given a coordinate, match that card 
    with the card immediately above. *)
(* Notice, that cards the top row fulfils this automatically.                     *)
let matchTop (row, col, cards) card =
  if row > 0 then
    let topCard = List.nth cards ((findIndexInList (row, col))-colNo)
    matchClothes (findBot topCard) (findTop card)
  else true

(* matchLeft: Given a coordinate, match that card 
    with the card immediately to the left. *)
let matchLeft (row, col, cards) card =
  if col > 0 then
    let leftCard = List.nth cards ((findIndexInList(row, col))-1)
    matchClothes (findRight leftCard) (findLeft card)
   else true

(* matchBot: Given a coordinate, match that card 
    with the card immediately below. *)
(* Notice, cards at the bottom row fulfils this automatically.                    *)
let matchBot (row, col, cards) card = 
  if row > 0 then
    let botCard = List.nth cards ((findIndexInList (row, col))+colNo)
    matchClothes (findTop botCard) (findBot card)
  else true

(* matchRight: Given a coordinate, match that card 
    with the card immediately to the right. *)
(* Notice, cards at the rightmost column fulfils this automatically.                       *)
let matchRight (row, col, cards) card =
  if col > 0 then
    let rightCard = List.nth cards ((findIndexInList(row, col))+1)
    matchClothes (findLeft rightCard) (findRight card)
   else true

(* Given a coordinate, match with cards immediately to the left and above. *)
let Match ((row, col, _) as board) card =
  (matchTop board card) && (matchLeft board card)

(* There is ONE error in the code below - and it never terminates   *)
(* If you correct this one error - everything will work just fine   *)
(* You must explain the error as a comment here:                   
   The add function (line 256) was called with a 0 instead of a 1, 
   so it never changed the position of where the cards were matched. 
   This means that the cards constantly were matched on the first
   position (0, 0), where no other cards were around it.  This would
   always succeed, and therefore it kept piling the cards on top of
   each other, and therefore it never terminated.                   *)
let rec findSol rest alreadyTried ((row,col,cards) as board) sols =
  match (rest,alreadyTried) with
    | ([],[]) -> board::sols 
      (* No rest and alreadyTried is empty, that is, solution found *)
    | ([],_) -> sols         
      (* No solution if alreadyTried is non empty. *)
    | (x::rest, alreadyTried) ->
      let sols' = 
        if Match board x then
          (* If there is a match, then go on with the rest of the cards *)
          let (row', col') = add 1 (row, col)
          findSol(rest@alreadyTried) [] (row', col', cards@[x]) sols
        else sols (* If no match then no new solutions found. *)
      (* Put the card x in alreadyTried and move on. *)
      findSol rest (x::alreadyTried) board sols'

(*----------------------------*
 * Generating a board.        *
 *----------------------------*)

let _ = printfn "Sequential version"
let res = findSol cardSet [] emptyBoard []
pp_boards res
let _ = printfn "Sequential solution with \%d solutions" (res.Length)

let _ = printfn "Simple parallel version where we spawn one search 
     with each card chosen first."
let boards = List.map (fun card -> (0,1,[card])) cardSet
let rests = List.map (fun (_,_,[card]) -> 
     List.filter (fun c -> c <> card) cardSet) boards

let work = List.map (fun (b,rest) -> 
     (fun () -> findSol rest [] b [])) (List.zip boards rests)
let allWork = List.toArray work
let parRes' = Array.Parallel.map (fun f -> f()) allWork
let parRes = List.concat (Array.toList parRes')
pp_boards parRes
let _ = printfn "Parallel solution with \%d solutions" (parRes.Length)

\end{lstlisting}